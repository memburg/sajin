/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package sajin

import java.awt.image.BufferedImage
import java.awt.image.DataBufferByte
import java.io.ByteArrayInputStream
import java.io.IOException
import java.util.*
import javax.imageio.ImageIO

object Sajin {
    /**
     * Gets the average value of each pixel, and if the result is inside
     * the range given by the standard deviation then the pixel will be
     * considered as a matched pixel.
     */
    fun softCompare(x: String, y: String, std: Int): Float {
        val a = 10.0f
        val b = 1.0f
        return a / b
    }

    /**
     * Compares pixel by pixel, each pixel must be in a range of the
     * standard deviation.
     */
    fun midCompare(expected: String, actual: String, std: Int): Float {
        val a = 10.0f
        val b = 1.0f
        return a / b
    }

    /**
     * Compares pixel by pixel, each pixel must be equal to be counted
     * as a matched pixel.
     */
    fun hardCompare(expected: String, actual: String): Float {
        // Create buffered image for both images
        val eb = createBufferedImage(expected)
        val ab = createBufferedImage(actual)

        // Validate widths are the same
        if (eb.width != ab.width) {
            throw Exception("No matching widths exception")
        }

        // Validate heights are the same
        if (eb.height != ab.height) {
            throw Exception("No matching heights exception")
        }

        var matched: Int = 0

        for (i in 0 until eb.height) {
            for (j in 0 until eb.width) {
                val ep: Int = eb.getRGB(j, i)
                val ap: Int = ab.getRGB(j, i)

                if (ep == ap) matched++
            }
        }

        val precision = matched.toFloat() / (eb.width * eb.height).toFloat() * 100
        println("Precision of $precision%")

        return precision
    }
    
    private fun createBufferedImage(im: String): BufferedImage {
        val imageData: ByteArray = Base64.getDecoder().decode(im)
        val bais = ByteArrayInputStream(imageData)

        try {
            return ImageIO.read(bais)
        } catch (e: IOException) {
            throw RuntimeException(e)
        }
    }

    private fun getPixels(im: BufferedImage) {

    }
}
